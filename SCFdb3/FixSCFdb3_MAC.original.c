/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern char byte_4060DC[]; // weak
extern char Str1[]; // idb
extern char Name[]; // idb
extern char aMicrosoftVisua[37]; // weak
extern char asc_406434[]; // idb
extern char aRuntimeErrorPr[]; // idb
extern char a___[]; // idb
extern char Source[]; // idb
extern char aScfdb3_exeWasP[40]; // weak
extern char aErrorCannotWri[33]; // weak
extern char aErrorCannotRea[32]; // weak
extern char aErrorCannotOpe[32]; // weak
extern char FileName[]; // idb
extern char a02x02x02x02x02[]; // idb
extern char aScfdb3Cracked_[27]; // weak
extern char aReturnsToOffer[25]; // weak
extern char aPlasma32Produc[25]; // weak
extern char aErrorCannotGet[37]; // weak
extern char aErrorCannotL_0[41]; // weak
extern char ProcName[]; // idb
extern char aErrorCannotLoa[40]; // weak
extern char LibFileName[]; // idb
extern int dword_4071E4; // weak
extern char *off_4071E8; // weak
extern wchar_t *off_4071EC; // weak
extern FILE File; // idb
extern int dword_407518[]; // weak
extern char off_40751C[140]; // idb
extern void *off_4075A8; // weak
extern LPVOID off_4075AC; // idb
extern int dword_4075B8; // weak
extern void **off_4095C8; // weak
extern int dword_4095CC; // weak
extern int (__cdecl *off_4095D0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
extern void *off_4095E8; // weak
extern _UNKNOWN unk_409910; // weak
extern int dword_409914[]; // weak
extern LPVOID Str; // idb
extern int dword_409A80; // weak
extern int dword_409A90; // weak
extern int dword_409A94; // weak
extern int dword_409BEC; // weak
extern int dword_409BF0; // weak
extern int dword_409E6C; // weak
extern int dword_409E70; // weak
extern void *Dst; // idb
extern int dword_409E78; // weak
extern LPVOID lpMem; // idb
extern int dword_409E80; // weak
extern HANDLE hHeap; // idb
extern int dword_409E88; // weak

//-------------------------------------------------------------------------
// Function declarations

int __cdecl main(int argc, const char **argv, const char **envp);
void __cdecl sub_4012C0(int lpMem);
// void *__cdecl operator new(unsigned int); idb
int __cdecl sub_4012D9(unsigned __int8 *a1, int a2);
void __cdecl sub_401432(int lpMem);
// void *__cdecl malloc(size_t Size);
LPVOID __cdecl sub_4014D9(unsigned int a1);
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
int __cdecl sub_401617(FILE *File, unsigned __int8 *a2, int a3);
int __cdecl loc_401A0D(FILE *File, int, int); // weak
// int __cdecl write_char(int, FILE *File, int); idb
// int __cdecl write_multi_char(int, int, FILE *File, int); idb
// int __cdecl write_string(int, int, FILE *File, int); idb
// _DWORD __cdecl get_int_arg(_DWORD); weak
// _DWORD __cdecl get_int64_arg(_DWORD); weak
// _DWORD __cdecl get_short_arg(_DWORD); weak
char __cdecl sub_4027A0(int a1);
__int32 __cdecl sub_4027CD();
signed int __cdecl sub_402915(int a1);
int __cdecl sub_402B7D(DWORD NumberOfBytesWritten); // idb
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// _DWORD __cdecl __sbh_find_block(_DWORD); weak
unsigned int __cdecl sub_402D43(unsigned int a1, int a2);
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
LPVOID __cdecl sub_403521();
BOOL __cdecl sub_403665(void **lpMem);
void __cdecl sub_4036BB(int a1);
int __cdecl sub_40377D(unsigned int a1, int a2, int a3);
void __cdecl sub_4037D4(int a1, int a2, int a3);
int __cdecl sub_403819(unsigned int a1);
int __cdecl sub_403A21(int a1, unsigned int a2, unsigned int a3);
// _DWORD __cdecl _callnewh(_DWORD); weak
int __cdecl sub_403C1D();
// _DWORD __cdecl flsall(_DWORD); weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl wctomb(char *MbCh, wchar_t WCh);
void *__cdecl sub_403F8A(size_t Size, int a2);
// char *__cdecl strcpy(char *Dest, const char *Source);
// char *__cdecl strcat(char *Dest, const char *Source);
// __int32 __cdecl strtol(const char *Str, char **EndPtr, int Radix);
// char *__cdecl strchr(const char *Str, int Val);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD); weak
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// void *__cdecl memcpy_0(void *Dst, const void *Src, size_t Size);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
unsigned int __cdecl sub_405A89(unsigned int a1);
// void __stdcall ExitProcess(UINT uExitCode);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPCH lpFilename, DWORD nSize);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// int wsprintfA(LPSTR, LPCSTR, ...);


//----- (00401000) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  HMODULE v3; // eax@1
  HMODULE v4; // esi@1
  FARPROC v5; // eax@3
  int v6; // ecx@7
  HANDLE v7; // eax@9
  void *v8; // edi@9
  int v10; // esi@11
  HANDLE v11; // eax@13
  void *v12; // edi@13
  unsigned __int8 *v13; // [sp-4h] [bp-4Ch]@2
  int v14; // [sp+0h] [bp-48h]@17
  DWORD v15; // [sp+10h] [bp-38h]@11
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-34h]@11
  int v17; // [sp+18h] [bp-30h]@7
  int v18; // [sp+1Ch] [bp-2Ch]@7
  char v19; // [sp+24h] [bp-24h]@5
  int v20; // [sp+2Eh] [bp-1Ah]@7
  __int16 v21; // [sp+32h] [bp-16h]@7
  CHAR v22; // [sp+34h] [bp-14h]@9
  char v23; // [sp+35h] [bp-13h]@13
  char v24; // [sp+37h] [bp-11h]@13
  char v25; // [sp+38h] [bp-10h]@13
  char v26; // [sp+3Ah] [bp-Eh]@13
  char v27; // [sp+3Bh] [bp-Dh]@13
  char v28; // [sp+3Dh] [bp-Bh]@13
  char v29; // [sp+3Eh] [bp-Ah]@13
  char v30; // [sp+40h] [bp-8h]@13
  char v31; // [sp+41h] [bp-7h]@13
  char v32; // [sp+43h] [bp-5h]@13
  char v33; // [sp+44h] [bp-4h]@13

  v3 = LoadLibraryA("RPCRT4.dll");
  v4 = v3;
  if ( v3 )
  {
    v5 = GetProcAddress(v3, "UuidCreateSequential");
    if ( v5 )
    {
      if ( ((int (__stdcall *)(char *))v5)(&v19) )
      {
        v13 = (unsigned __int8 *)"Error : Cannot get internal adapter\n";
      }
      else
      {
        FreeLibrary(v4);
        sub_4012D9((unsigned __int8 *)"PLASMA32 productions...\n", v14);
        Sleep(2000);
        sub_4012D9((unsigned __int8 *)"Returns to offer you...\n", v14);
        Sleep(0x7D0u);
        sub_4012D9((unsigned __int8 *)"SCFdb3 cracked. Enjoy it!\n", v14);
        Sleep(0x7D0u);
        v17 = v20;
        LOWORD(v18) = v21;
        v6 = 0;
        do
          ++v6;
        while ( v6 + 2 < 8 );
        wsprintfA(
          &v22,
          "%02X-%02X-%02X-%02X-%02X-%02X",
          BYTE1(v17),
          (unsigned __int8)v20,
          BYTE3(v17),
          BYTE1(v18),
          (unsigned __int8)v18,
          BYTE2(v17));
        v7 = CreateFileA(".\\SCFdb3.exe", -1073741824u, 3u, 0, 3u, 128u, 0);
        v8 = v7;
        if ( v7 == (HANDLE)-1 )
        {
          sub_4012D9((unsigned __int8 *)"Error : Cannot open SCFdb3.exe\n", v14);
          Sleep(0x1388u);
          return 1;
        }
        v15 = GetFileSize(v7, 0);
        v10 = (int)operator new(v15);
        if ( !ReadFile(v8, (LPVOID)v10, v15, &NumberOfBytesWritten, 0) )
        {
          sub_4012D9((unsigned __int8 *)"Error : Cannot read SCFdb3.exe\n", v14);
          Sleep(0x1388u);
          return 1;
        }
        CloseHandle(v8);
        *(_BYTE *)(v10 + 68725) = v22;
        *(_BYTE *)(v10 + 68727) = v23;
        *(_BYTE *)(v10 + 68731) = v24;
        *(_BYTE *)(v10 + 68733) = v25;
        *(_BYTE *)(v10 + 68737) = v26;
        *(_BYTE *)(v10 + 68739) = v27;
        *(_BYTE *)(v10 + 68743) = v28;
        *(_BYTE *)(v10 + 68745) = v29;
        *(_BYTE *)(v10 + 68749) = v30;
        *(_BYTE *)(v10 + 68751) = v31;
        *(_BYTE *)(v10 + 68755) = v32;
        *(_BYTE *)(v10 + 68757) = v33;
        v11 = CreateFileA(".\\SCFdb3.exe", 0xC0000000u, 3u, 0, 2u, 0x80u, 0);
        v12 = v11;
        if ( v11 == (HANDLE)-1 )
        {
          v13 = (unsigned __int8 *)"Error : Cannot open SCFdb3.exe\n";
        }
        else
        {
          if ( WriteFile(v11, (LPCVOID)v10, v15, &NumberOfBytesWritten, 0) )
          {
            CloseHandle(v12);
            sub_4012D9((unsigned __int8 *)"SCFdb3.exe was patched successfully!!!\n", v14);
            sub_4012C0(v10);
            Sleep(0x2328u);
            ExitProcess(0);
          }
          v13 = (unsigned __int8 *)"Error : Cannot write SCFdb3.exe\n";
        }
      }
    }
    else
    {
      v13 = (unsigned __int8 *)"Error : Cannot load critical procedures\n";
    }
  }
  else
  {
    v13 = (unsigned __int8 *)"Error : Cannot load critical libraries\n";
  }
  sub_4012D9(v13, v14);
  Sleep(0x1388u);
  return 1;
}

//----- (004012C0) --------------------------------------------------------
void __cdecl sub_4012C0(int lpMem)
{
  sub_401432(lpMem);
}

//----- (004012D9) --------------------------------------------------------
int __cdecl sub_4012D9(unsigned __int8 *a1, int a2)
{
  int v3; // edi@1
  int v4; // ebx@1

  v3 = _stbuf(&File);
  v4 = sub_401617(&File, a1, (int)&a2);
  _ftbuf(v3, &File);
  return v4;
}
// 40154D: using guessed type _DWORD __cdecl _stbuf(_DWORD);
// 4015DA: using guessed type _DWORD __cdecl _ftbuf(_DWORD, _DWORD);

//----- (00401432) --------------------------------------------------------
void __cdecl sub_401432(int lpMem)
{
  int v1; // esi@1
  unsigned int v2; // eax@3
  int v3; // eax@6
  void *v4; // [sp-4h] [bp-Ch]@3
  int v5; // [sp+4h] [bp-4h]@6

  v1 = lpMem;
  if ( lpMem )
  {
    if ( dword_409E88 == 3 )
    {
      v2 = __sbh_find_block(lpMem);
      v4 = (void *)v1;
      if ( v2 )
      {
        sub_402D43(v2, v1);
        return;
      }
    }
    else
    {
      if ( dword_409E88 == 2 )
      {
        v3 = sub_40377D(lpMem, (int)&v5, (int)&lpMem);
        if ( v3 )
        {
          sub_4037D4(v5, lpMem, v3);
          return;
        }
      }
      v4 = (void *)v1;
    }
    HeapFree(hHeap, 0, v4);
  }
}
// 402D18: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 409E88: using guessed type int dword_409E88;

//----- (004014D9) --------------------------------------------------------
LPVOID __cdecl sub_4014D9(unsigned int a1)
{
  signed int v1; // esi@1
  LPVOID result; // eax@3
  int v3; // esi@7

  v1 = a1;
  if ( dword_409E88 == 3 )
  {
    if ( a1 <= dword_409E80 )
    {
      result = (LPVOID)__sbh_alloc_block(a1);
      if ( result )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_409E88 != 2 )
  {
LABEL_12:
    if ( !a1 )
      v1 = 1;
    v3 = (v1 + 15) & 0xFFFFFFF0;
    return HeapAlloc(hHeap, 0, v3);
  }
  if ( a1 )
    v3 = (a1 + 15) & 0xFFFFFFF0;
  else
    v3 = 16;
  if ( v3 > (unsigned int)dword_4095CC || (result = (LPVOID)sub_403819((unsigned int)v3 >> 4), !result) )
    return HeapAlloc(hHeap, 0, v3);
  return result;
}
// 40306C: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 4095CC: using guessed type int dword_4095CC;
// 409E80: using guessed type int dword_409E80;
// 409E88: using guessed type int dword_409E88;

//----- (00401617) --------------------------------------------------------
int __cdecl sub_401617(FILE *File, unsigned __int8 *a2, int a3)
{
  int v3; // ecx@1
  unsigned __int8 v4; // bl@1
  int v5; // esi@1
  char v6; // zf@1
  signed int v7; // edx@2
  signed int v8; // edi@2
  int v9; // eax@7
  int v10; // eax@22
  int v11; // eax@23
  signed int v12; // esi@55
  int v13; // eax@57
  char *v14; // ecx@57
  char *i; // eax@60
  signed int v16; // edx@61
  char *v17; // edi@65
  wchar_t v18; // ax@70
  int v19; // eax@78
  int v20; // ecx@79
  int v21; // eax@81
  int v22; // eax@82
  void *v23; // eax@90
  char *j; // eax@106
  signed int v25; // edx@107
  int v26; // eax@117
  __int64 v27; // qax@124
  int v28; // eax@148
  signed int v29; // ebx@150
  int v30; // eax@152
  int v31; // eax@153
  char v32; // bl@159
  int v33; // esi@167
  int v34; // ebx@174
  int v35; // edi@174
  wchar_t v36; // ax@175
  int v37; // eax@175
  int v38; // eax@176
  char v39; // zf@183
  char MbCh; // [sp+Ch] [bp-24Ch]@65
  char v42; // [sp+20Bh] [bp-4Dh]@147
  int v43; // [sp+20Ch] [bp-4Ch]@93
  int v44; // [sp+210h] [bp-48h]@93
  int v45; // [sp+214h] [bp-44h]@175
  char *Str; // [sp+218h] [bp-40h]@10
  int v47; // [sp+21Ch] [bp-3Ch]@3
  int v48; // [sp+220h] [bp-38h]@10
  int v49; // [sp+224h] [bp-34h]@102
  LPVOID lpMem; // [sp+228h] [bp-30h]@1
  int v51; // [sp+22Ch] [bp-2Ch]@10
  int v52; // [sp+230h] [bp-28h]@10
  int v53; // [sp+234h] [bp-24h]@10
  unsigned __int64 v54; // [sp+238h] [bp-20h]@137
  _BYTE v55[6]; // [sp+242h] [bp-16h]@1
  int v56; // [sp+248h] [bp-10h]@1
  int v57; // [sp+24Ch] [bp-Ch]@57
  int v58; // [sp+250h] [bp-8h]@10
  int v59; // [sp+254h] [bp-4h]@10
  int v60; // [sp+264h] [bp+Ch]@1

  v3 = 0;
  v56 = 0;
  v4 = *a2;
  v5 = (int)(a2 + 1);
  v6 = *a2 == 0;
  *(_DWORD *)&v55[2] = 0;
  lpMem = 0;
  v60 = (int)(a2 + 1);
  if ( !v6 )
  {
    v8 = 2048;
    v7 = 512;
    while ( 1 )
    {
      if ( *(_DWORD *)&v55[2] < 0 )
        return *(_DWORD *)&v55[2];
      if ( (char)v4 < 32 || (char)v4 > 120 )
        v9 = 0;
      else
        v9 = *((_BYTE *)&SetStdHandle + (char)v4) & 0xF;
      v47 = *(&byte_4060DC[8 * v9] + v3) >> 4;
      switch ( v47 )
      {
        case 1:
          v58 = -1;
          Str = 0;
          v48 = 0;
          v52 = 0;
          v53 = 0;
          v59 = 0;
          v51 = 0;
          goto LABEL_183;
        case 2:
          switch ( v4 )
          {
            case 32u:
              v59 |= 2u;
              break;
            case 35u:
              LOBYTE(v59) = v59 | 0x80;
              break;
            case 43u:
              v59 |= 1u;
              break;
            case 45u:
              v59 |= 4u;
              break;
            case 48u:
              v59 |= 8u;
              break;
          }
          goto LABEL_183;
        case 3:
          if ( v4 == 42 )
          {
            v10 = get_int_arg(&a3);
            v52 = v10;
            if ( v10 >= 0 )
              goto LABEL_183;
            v59 |= 4u;
            v11 = -v10;
          }
          else
          {
            v11 = (char)v4 + 10 * v52 - 48;
          }
          v52 = v11;
          goto LABEL_183;
        case 4:
          v58 = 0;
          goto LABEL_183;
        case 5:
          if ( v4 == 42 )
          {
            v58 = get_int_arg(&a3);
            if ( v58 < 0 )
              v58 = -1;
          }
          else
          {
            v58 = (char)v4 + 10 * v58 - 48;
          }
          goto LABEL_183;
        case 6:
          switch ( v4 )
          {
            case 0x49u:
              if ( *(_BYTE *)v5 != 54 || *(_BYTE *)(v5 + 1) != 52 )
              {
                v47 = 0;
LABEL_42:
                v51 = 0;
                if ( *((_BYTE *)off_4095E8 + 2 * v4 + 1) & 0x80 )
                {
                  write_char((char)v4, File, (int)&v55[2]);
                  v4 = *(_BYTE *)v5;
                  v60 = v5 + 1;
                }
                write_char((char)v4, File, (int)&v55[2]);
              }
              else
              {
                BYTE1(v59) |= 0x80u;
                v60 = v5 + 2;
              }
              break;
            case 0x68u:
              v59 |= 0x20u;
              break;
            case 0x6Cu:
              v59 |= 0x10u;
              break;
            case 0x77u:
              v59 |= v8;
              break;
          }
          goto LABEL_183;
        case 0:
          goto LABEL_42;
        case 7:
          if ( (char)v4 <= 103 )
          {
            if ( (char)v4 >= 101 )
              goto LABEL_65;
            if ( (char)v4 > 88 )
            {
              if ( (char)v4 == 90 )
              {
                v19 = get_int_arg(&a3);
                if ( !v19 || (v20 = *(_DWORD *)(v19 + 4), !v20) )
                {
                  v57 = (int)off_4071E8;
                  v22 = strlen(off_4071E8);
                  goto LABEL_157;
                }
                if ( !(v8 & v59) )
                {
                  v51 = 0;
                  v57 = v20;
                  v22 = *(_WORD *)v19;
                  goto LABEL_157;
                }
                v21 = (unsigned int)*(_WORD *)v19 >> 1;
                v57 = v20;
                v56 = v21;
                v51 = 1;
                goto LABEL_158;
              }
              if ( (char)v4 != 99 )
              {
                if ( (char)v4 != 100 )
                  goto LABEL_158;
LABEL_121:
                v59 |= 0x40u;
                goto LABEL_122;
              }
            }
            else
            {
              if ( (char)v4 == 88 )
                goto LABEL_112;
              if ( (char)v4 != 67 )
              {
                if ( (char)v4 == 69 || (char)v4 == 71 )
                {
                  Str = (char *)1;
                  v4 += 32;
LABEL_65:
                  v59 |= 0x40u;
                  v17 = &MbCh;
                  v57 = (int)&MbCh;
                  if ( v58 >= 0 )
                  {
                    if ( v58 )
                    {
                      if ( v58 > v7 )
                        v58 = v7;
                      if ( v58 > 163 )
                      {
                        v23 = malloc(v58 + 349);
                        lpMem = v23;
                        if ( v23 )
                        {
                          v17 = (char *)v23;
                          v57 = (int)v23;
                        }
                        else
                        {
                          v58 = 163;
                        }
                      }
                    }
                    else
                    {
                      if ( v4 == 103 )
                        v58 = 1;
                    }
                  }
                  else
                  {
                    v58 = 6;
                  }
                  a3 += 8;
                  v43 = *(_DWORD *)(a3 - 8);
                  v44 = *(_DWORD *)(a3 - 4);
                  off_4095D0(&v43, v17, (char)v4, v58, Str);
                  JUMPOUT(*(int *)loc_401A0D);
                }
                if ( (char)v4 != 83 )
                  goto LABEL_158;
                if ( !(v59 & 0x830) )
                  v59 |= v8;
                goto LABEL_55;
              }
              if ( !(v59 & 0x830) )
                v59 |= v8;
            }
            if ( v59 & 0x810 )
            {
              v18 = get_short_arg(&a3);
              v56 = wctomb(&MbCh, v18);
              if ( v56 < 0 )
                v48 = 1;
            }
            else
            {
              MbCh = get_int_arg(&a3);
              v56 = 1;
            }
            v57 = (int)&MbCh;
            goto LABEL_158;
          }
          if ( (char)v4 == 105 )
            goto LABEL_121;
          if ( (char)v4 != 110 )
          {
            if ( (char)v4 == 111 )
            {
              v56 = 8;
              if ( v59 & 0x80 )
                v59 |= v7;
              goto LABEL_123;
            }
            if ( (char)v4 != 112 )
            {
              if ( (char)v4 != 115 )
              {
                if ( (char)v4 != 117 )
                {
                  if ( (char)v4 == 120 )
                  {
                    v49 = 39;
LABEL_113:
                    v56 = 16;
                    if ( v59 & 0x80 )
                    {
                      v55[0] = 48;
                      v53 = 2;
                      v55[1] = v49 + 81;
                    }
LABEL_123:
                    if ( BYTE1(v59) & 0x80 )
                    {
                      LODWORD(v27) = get_int64_arg(&a3);
                    }
                    else
                    {
                      if ( v59 & 0x20 )
                      {
                        LODWORD(v27) = v59 & 0x40 ? (signed __int16)get_int_arg(&a3) : (unsigned __int16)get_int_arg(&a3);
                      }
                      else
                      {
                        if ( !(v59 & 0x40) )
                        {
                          v27 = get_int_arg(&a3);
                          goto LABEL_133;
                        }
                        LODWORD(v27) = get_int_arg(&a3);
                      }
                      v27 = (signed int)v27;
                    }
LABEL_133:
                    if ( v59 & 0x40 && HIDWORD(v27) <= 0 && HIDWORD(v27) < 0 )
                    {
                      LODWORD(v54) = v27;
                      BYTE1(v59) |= 1u;
                      HIDWORD(v54) = (unsigned __int64)-v27 >> 32;
                    }
                    else
                    {
                      v54 = v27;
                    }
                    if ( !(BYTE1(v59) & 0x80) )
                      HIDWORD(v54) = 0;
                    if ( v58 >= 0 )
                    {
                      v59 &= 0xFFFFFFF7u;
                      if ( v58 > 512 )
                        v58 = 512;
                    }
                    else
                    {
                      v58 = 1;
                    }
                    if ( !v54 )
                      v53 = 0;
                    v57 = (int)&v42;
                    while ( 1 )
                    {
                      v28 = v58--;
                      if ( v28 <= 0 )
                      {
                        if ( !v54 )
                          break;
                      }
                      v29 = v54 % v56 + 48;
                      v54 /= (unsigned __int64)v56;
                      if ( v29 > 57 )
                        v29 += v49;
                      v30 = v57--;
                      *(_BYTE *)v30 = v29;
                    }
                    v31 = (int)(&v42 - v57++);
                    v56 = v31;
                    if ( BYTE1(v59) & 2 )
                    {
                      if ( *(_BYTE *)v57 != 48 || !v31 )
                      {
                        --v57;
                        v22 = v31 + 1;
                        *(_BYTE *)v57 = 48;
                        goto LABEL_157;
                      }
                    }
                  }
LABEL_158:
                  if ( v48 )
                    goto LABEL_181;
                  v32 = v59;
                  if ( v59 & 0x40 )
                  {
                    if ( BYTE1(v59) & 1 )
                    {
                      v55[0] = 45;
                      goto LABEL_166;
                    }
                    if ( v59 & 1 )
                    {
                      v55[0] = 43;
                      goto LABEL_166;
                    }
                    if ( v59 & 2 )
                    {
                      v55[0] = 32;
LABEL_166:
                      v53 = 1;
                    }
                  }
                  v33 = v52 - v53 - v56;
                  if ( !(v59 & 0xC) )
                    write_multi_char(32, v52 - v53 - v56, File, (int)&v55[2]);
                  write_string((int)v55, v53, File, (int)&v55[2]);
                  if ( v32 & 8 )
                  {
                    if ( !(v32 & 4) )
                      write_multi_char(48, v33, File, (int)&v55[2]);
                  }
                  if ( v51 && v56 > 0 )
                  {
                    v34 = v57;
                    v35 = v56 - 1;
                    do
                    {
                      v36 = *(_WORD *)v34;
                      v34 += 2;
                      v37 = wctomb((char *)&v45, v36);
                      if ( v37 <= 0 )
                        break;
                      write_string((int)&v45, v37, File, (int)&v55[2]);
                      v38 = v35--;
                    }
                    while ( v38 );
                  }
                  else
                  {
                    write_string(v57, v56, File, (int)&v55[2]);
                  }
                  if ( v59 & 4 )
                    write_multi_char(32, v33, File, (int)&v55[2]);
                  goto LABEL_181;
                }
LABEL_122:
                v56 = 10;
                goto LABEL_123;
              }
LABEL_55:
              v12 = 2147483647;
              if ( v58 != -1 )
                v12 = v58;
              v13 = get_int_arg(&a3);
              v14 = (char *)v13;
              v57 = v13;
              if ( v59 & 0x810 )
              {
                if ( !v13 )
                {
                  v14 = (char *)off_4071EC;
                  v57 = (int)off_4071EC;
                }
                v51 = 1;
                for ( i = v14; ; i += 2 )
                {
                  v16 = v12--;
                  if ( !v16 )
                    break;
                  if ( !*(_WORD *)i )
                    break;
                }
                v22 = (signed int)(i - v14) >> 1;
              }
              else
              {
                if ( !v13 )
                {
                  v14 = off_4071E8;
                  v57 = (int)off_4071E8;
                }
                for ( j = v14; ; ++j )
                {
                  v25 = v12--;
                  if ( !v25 )
                    break;
                  if ( !*j )
                    break;
                }
                v22 = j - v14;
              }
LABEL_157:
              v56 = v22;
              goto LABEL_158;
            }
            v58 = 8;
LABEL_112:
            v49 = 7;
            goto LABEL_113;
          }
          v26 = get_int_arg(&a3);
          if ( v59 & 0x20 )
            *(_WORD *)v26 = *(_WORD *)&v55[2];
          else
            *(_DWORD *)v26 = *(_DWORD *)&v55[2];
          v48 = 1;
LABEL_181:
          if ( lpMem )
          {
            sub_401432((int)lpMem);
            lpMem = 0;
          }
LABEL_183:
          v4 = *(_BYTE *)v60;
          v5 = v60 + 1;
          v39 = *(_BYTE *)v60++ == 0;
          if ( v39 )
            return *(_DWORD *)&v55[2];
          v3 = v47;
          v7 = 512;
          v8 = 2048;
          break;
        default:
          goto LABEL_183;
      }
    }
  }
  return *(_DWORD *)&v55[2];
}
// 401A0D: using guessed type int __cdecl(FILE *File, int, int);
// 401E53: using guessed type _DWORD __cdecl get_int_arg(_DWORD);
// 401E60: using guessed type _DWORD __cdecl get_int64_arg(_DWORD);
// 401E70: using guessed type _DWORD __cdecl get_short_arg(_DWORD);
// 4071E8: using guessed type char *off_4071E8;
// 4071EC: using guessed type wchar_t *off_4071EC;
// 4095D0: using guessed type int (__cdecl *off_4095D0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4095E8: using guessed type void *off_4095E8;

//----- (004027A0) --------------------------------------------------------
char __cdecl sub_4027A0(int a1)
{
  HMODULE v1; // eax@1
  int v2; // ecx@2

  *(_DWORD *)a1 = 0;
  v1 = GetModuleHandleA(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *((_DWORD *)v1 + 15);
    if ( v2 )
    {
      v1 = (char *)v1 + v2;
      *(_BYTE *)a1 = *((_BYTE *)v1 + 26);
      LOBYTE(v1) = *((_BYTE *)v1 + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)v1;
    }
  }
  return (char)v1;
}

//----- (004027CD) --------------------------------------------------------
__int32 __cdecl sub_4027CD()
{
  __int32 result; // eax@4
  CHAR *v1; // ecx@6
  CHAR v2; // al@7
  char *v3; // eax@12
  CHAR *v4; // ecx@13
  CHAR v5; // al@14
  char *v6; // eax@20
  const char *v7; // eax@21
  const char *v8; // ecx@21
  CHAR Str2; // [sp+4h] [bp-122Ch]@5
  CHAR SubStr; // [sp+1094h] [bp-19Ch]@13
  struct _OSVERSIONINFOA VersionInformation; // [sp+1198h] [bp-98h]@1
  unsigned __int8 v12; // [sp+122Ch] [bp-4h]@29

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    result = 1;
  }
  else
  {
    if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", &Str2, 0x1090u) )
      goto LABEL_32;
    v1 = &Str2;
    if ( Str2 )
    {
      do
      {
        v2 = *v1;
        if ( *v1 >= 97 )
        {
          if ( v2 <= 122 )
            *v1 = v2 - 32;
        }
        ++v1;
      }
      while ( *v1 );
    }
    if ( strncmp("__GLOBAL_HEAP_SELECTED", &Str2, 0x16u) )
    {
      GetModuleFileNameA(0, &SubStr, 0x104u);
      v4 = &SubStr;
      if ( SubStr )
      {
        do
        {
          v5 = *v4;
          if ( *v4 >= 97 )
          {
            if ( v5 <= 122 )
              *v4 = v5 - 32;
          }
          ++v4;
        }
        while ( *v4 );
      }
      v3 = strstr(&Str2, &SubStr);
    }
    else
    {
      v3 = &Str2;
    }
    if ( !v3 )
      goto LABEL_32;
    v6 = strchr(v3, 44);
    if ( !v6 )
      goto LABEL_32;
    v7 = v6 + 1;
    v8 = v7;
    while ( *v8 )
    {
      if ( *v8 == 59 )
        *v8 = 0;
      else
        ++v8;
    }
    result = strtol(v7, 0, 10);
    if ( result != 2 )
    {
      if ( result != 3 && result != 1 )
      {
LABEL_32:
        sub_4027A0((int)&v12);
        result = 3 - (v12 < 6u);
      }
    }
  }
  return result;
}

//----- (00402915) --------------------------------------------------------
signed int __cdecl sub_402915(int a1)
{
  __int32 v1; // eax@2
  LPVOID v2; // eax@3

  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  v1 = sub_4027CD();
  dword_409E88 = v1;
  if ( v1 == 3 )
  {
    v2 = (LPVOID)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_403521();
  }
  if ( !v2 )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}
// 402CD0: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 409E88: using guessed type int dword_409E88;

//----- (00402B7D) --------------------------------------------------------
BOOL __cdecl sub_402B7D(DWORD NumberOfBytesWritten)
{
  BOOL result; // eax@1
  int v2; // ecx@1
  int v3; // esi@4
  char *v4; // edi@11
  const char **v5; // esi@14
  DWORD v6; // ST24_4@14
  const void *v7; // ST20_4@14
  HANDLE v8; // eax@14
  CHAR Source; // [sp+0h] [bp-1A4h]@9
  char Dest; // [sp+104h] [bp-A0h]@13
  int v11; // [sp+1A4h] [bp+0h]@12

  v2 = 0;
  result = (BOOL)dword_407518;
  do
  {
    if ( NumberOfBytesWritten == *(_DWORD *)result )
      break;
    result += 8;
    ++v2;
  }
  while ( result < (unsigned int)&off_4075A8 );
  v3 = 8 * v2;
  if ( NumberOfBytesWritten == dword_407518[2 * v2] )
  {
    result = dword_409A80;
    if ( dword_409A80 != 1 && (dword_409A80 || dword_4071E4 != 1) )
    {
      if ( NumberOfBytesWritten != 252 )
      {
        if ( !GetModuleFileNameA(0, &Source, 0x104u) )
          strcpy(&Source, "<program name unknown>");
        v4 = &Source;
        if ( strlen(&Source) + 1 > 0x3C )
        {
          v4 = (char *)&v11 + strlen(&Source) - 479;
          strncpy(v4, "...", 3u);
        }
        strcpy(&Dest, "Runtime Error!\n\nProgram: ");
        strcat(&Dest, v4);
        strcat(&Dest, "\n\n");
        strcat(&Dest, *(const char **)&off_40751C[v3]);
        result = __crtMessageBoxA(&Dest, "Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      v5 = (const char **)&off_40751C[v3];
      v6 = strlen(*v5);
      v7 = *v5;
      v8 = GetStdHandle(0xFFFFFFF4u);
      result = WriteFile(v8, v7, v6, &NumberOfBytesWritten, 0);
    }
  }
  return result;
}
// 404C8F: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD);
// 4071E4: using guessed type int dword_4071E4;
// 407518: using guessed type int dword_407518[];
// 4075A8: using guessed type void *off_4075A8;
// 409A80: using guessed type int dword_409A80;

//----- (00402D43) --------------------------------------------------------
unsigned int __cdecl sub_402D43(unsigned int a1, int a2)
{
  unsigned int result; // eax@1
  signed int v3; // ecx@1
  unsigned int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int v7; // edx@3
  unsigned int v8; // ebx@7
  int v9; // ecx@7
  char v10; // zf@7
  unsigned int v11; // ebx@9
  int v12; // ecx@9
  char v13; // zf@9
  int v14; // ecx@11
  int v15; // edx@14
  int v16; // ebx@17
  unsigned int v17; // esi@24
  char v18; // zf@24
  unsigned int v19; // esi@26
  char v20; // zf@26
  int v21; // ecx@33
  char v22; // zf@41
  void *v23; // eax@43
  int v24; // [sp+Ch] [bp-10h]@1
  signed int v25; // [sp+10h] [bp-Ch]@2
  signed int v26; // [sp+14h] [bp-8h]@2
  int v27; // [sp+18h] [bp-4h]@1
  int v28; // [sp+28h] [bp+Ch]@2
  int v29; // [sp+28h] [bp+Ch]@17
  char v30; // [sp+2Bh] [bp+Fh]@34

  result = *(_DWORD *)(a1 + 16);
  v5 = a2 - 4;
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v24 = 516 * v4 + result + 324;
  v3 = *(_DWORD *)(a2 - 4) - 1;
  v27 = *(_DWORD *)(a2 - 4) - 1;
  if ( !(v3 & 1) )
  {
    v6 = v3 + v5;
    v25 = *(_DWORD *)(v3 + v5);
    v26 = *(_DWORD *)(a2 - 8);
    v28 = v3 + v5;
    if ( !(v25 & 1) )
    {
      v7 = (v25 >> 4) - 1;
      if ( (unsigned int)v7 > 0x3F )
        v7 = 63;
      if ( *(_DWORD *)(v6 + 4) == *(_DWORD *)(v6 + 8) )
      {
        if ( (unsigned int)v7 >= 0x20 )
        {
          v12 = v7 + result + 4;
          v11 = ~(0x80000000u >> (v7 - 32));
          *(_DWORD *)(result + 4 * v4 + 196) &= v11;
          v13 = *(_BYTE *)v12-- == 1;
          if ( v13 )
            *(_DWORD *)(a1 + 4) &= v11;
        }
        else
        {
          v9 = v7 + result + 4;
          v8 = ~(0x80000000u >> v7);
          *(_DWORD *)(result + 4 * v4 + 68) &= v8;
          v10 = *(_BYTE *)v9-- == 1;
          if ( v10 )
            *(_DWORD *)a1 &= v8;
        }
        v14 = v27;
        v6 = v28;
      }
      else
      {
        v14 = v27;
      }
      v3 = v25 + v14;
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = *(_DWORD *)(v6 + 4);
      v27 = v3;
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 8) = *(_DWORD *)(v28 + 8);
    }
    v15 = (v3 >> 4) - 1;
    if ( (unsigned int)v15 > 0x3F )
      v15 = 63;
    if ( v26 & 1 )
    {
      v16 = a1;
    }
    else
    {
      v29 = v5 - v26;
      v16 = (v26 >> 4) - 1;
      if ( (unsigned int)v16 > 0x3F )
        v16 = 63;
      v27 = v26 + v3;
      v15 = ((v26 + v3) >> 4) - 1;
      if ( (unsigned int)v15 > 0x3F )
        v15 = 63;
      if ( v16 != v15 )
      {
        if ( *(_DWORD *)(v29 + 4) == *(_DWORD *)(v29 + 8) )
        {
          if ( (unsigned int)v16 >= 0x20 )
          {
            v19 = ~(0x80000000u >> (v16 - 32));
            *(_DWORD *)(result + 4 * v4 + 196) &= v19;
            v20 = *(_BYTE *)(v16 + result + 4)-- == 1;
            if ( v20 )
              *(_DWORD *)(a1 + 4) &= v19;
          }
          else
          {
            v17 = ~(0x80000000u >> v16);
            *(_DWORD *)(result + 4 * v4 + 68) &= v17;
            v18 = *(_BYTE *)(v16 + result + 4)-- == 1;
            if ( v18 )
              *(_DWORD *)a1 &= v17;
          }
        }
        *(_DWORD *)(*(_DWORD *)(v29 + 8) + 4) = *(_DWORD *)(v29 + 4);
        *(_DWORD *)(*(_DWORD *)(v29 + 4) + 8) = *(_DWORD *)(v29 + 8);
      }
      v5 = v29;
    }
    if ( v26 & 1 || v16 != v15 )
    {
      v21 = v24 + 8 * v15;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v24 + 8 * v15 + 4);
      *(_DWORD *)(v5 + 8) = v21;
      *(_DWORD *)(v21 + 4) = v5;
      *(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) = v5;
      if ( *(_DWORD *)(v5 + 4) == *(_DWORD *)(v5 + 8) )
      {
        v30 = *(_BYTE *)(v15 + result + 4);
        *(_BYTE *)(v15 + result + 4) = v30 + 1;
        if ( (unsigned int)v15 >= 0x20 )
        {
          if ( !v30 )
            *(_DWORD *)(a1 + 4) |= 0x80000000u >> (v15 - 32);
          *(_DWORD *)(result + 4 * v4 + 196) |= 0x80000000u >> (v15 - 32);
        }
        else
        {
          if ( !v30 )
            *(_DWORD *)a1 |= 0x80000000u >> v15;
          *(_DWORD *)(result + 4 * v4 + 68) |= 0x80000000u >> v15;
        }
      }
    }
    *(_DWORD *)v5 = v27;
    *(_DWORD *)(v27 + v5 - 4) = v27;
    result += 516 * v4 + 324;
    v22 = *(_DWORD *)v24 == 1;
    --*(_DWORD *)result;
    if ( v22 )
    {
      if ( Dst )
      {
        VirtualFree((LPVOID)(*((_DWORD *)Dst + 3) + (dword_409E6C << 15)), 32768u, 16384u);
        *((_DWORD *)Dst + 2) |= 0x80000000u >> dword_409E6C;
        *(_DWORD *)(*((_DWORD *)Dst + 4) + 4 * dword_409E6C + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)Dst + 4) + 67);
        v23 = Dst;
        if ( !*(_BYTE *)(*((_DWORD *)Dst + 4) + 67) )
        {
          *((_DWORD *)Dst + 1) &= 0xFFFFFFFEu;
          v23 = Dst;
        }
        if ( *((_DWORD *)v23 + 2) == -1 )
        {
          VirtualFree(*((LPVOID *)v23 + 3), 0, 0x8000u);
          HeapFree(hHeap, 0, *((LPVOID *)Dst + 4));
          memcpy_0(Dst, (char *)Dst + 20, (size_t)(lpMem + 20 * dword_409E78-- - (_DWORD)Dst - 20));
          if ( a1 > (unsigned int)Dst )
            a1 -= 20;
          dword_409E70 = (int)lpMem;
        }
      }
      result = a1;
      dword_409E6C = v4;
      Dst = (void *)a1;
    }
  }
  return result;
}
// 409E6C: using guessed type int dword_409E6C;
// 409E70: using guessed type int dword_409E70;
// 409E78: using guessed type int dword_409E78;

//----- (00403521) --------------------------------------------------------
LPVOID __cdecl sub_403521()
{
  LPVOID v0; // esi@2
  void *v1; // eax@4
  unsigned int v2; // edi@4
  int v3; // eax@12
  signed int v4; // ebp@12
  bool v5; // edx@13

  if ( dword_4075B8 == -1 )
  {
    v0 = &off_4075A8;
  }
  else
  {
    v0 = HeapAlloc(hHeap, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 4194304u, 8192u, 4u);
  v2 = (unsigned int)v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != &off_4075A8 )
      HeapFree(hHeap, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree((LPVOID)v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == &off_4075A8 )
  {
    if ( !off_4075A8 )
      off_4075A8 = &off_4075A8;
    if ( !off_4075AC )
      off_4075AC = &off_4075A8;
  }
  else
  {
    *(_DWORD *)v0 = &off_4075A8;
    *((_DWORD *)v0 + 1) = off_4075AC;
    off_4075AC = v0;
    **((_DWORD **)v0 + 1) = v0;
  }
  *((_DWORD *)v0 + 5) = v2 + 4194304;
  v3 = (int)((char *)v0 + 24);
  *((_DWORD *)v0 + 3) = (char *)v0 + 152;
  *((_DWORD *)v0 + 4) = v2;
  *((_DWORD *)v0 + 2) = (char *)v0 + 24;
  v4 = 0;
  do
  {
    v5 = v4++ >= 16;
    *(_DWORD *)v3 = ((v5 - 1) & 0xF1) - 1;
    *(_DWORD *)(v3 + 4) = 241;
    v3 += 8;
  }
  while ( v4 < 1024 );
  memset((void *)v2, 0, 0x10000u);
  while ( v2 < *((_DWORD *)v0 + 4) + 65536 )
  {
    *(_BYTE *)(v2 + 248) = -1;
    *(_DWORD *)v2 = v2 + 8;
    *(_DWORD *)(v2 + 4) = 240;
    v2 += 4096;
  }
  return v0;
}
// 4075A8: using guessed type void *off_4075A8;
// 4075B8: using guessed type int dword_4075B8;

//----- (00403665) --------------------------------------------------------
BOOL __cdecl sub_403665(void **lpMem)
{
  BOOL result; // eax@1

  result = VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_4095C8 == lpMem )
  {
    result = (BOOL)lpMem[1];
    off_4095C8 = (void **)lpMem[1];
  }
  if ( lpMem == &off_4075A8 )
  {
    dword_4075B8 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    result = HeapFree(hHeap, 0, lpMem);
  }
  return result;
}
// 4075A8: using guessed type void *off_4075A8;
// 4075B8: using guessed type int dword_4075B8;
// 4095C8: using guessed type void **off_4095C8;

//----- (004036BB) --------------------------------------------------------
void __cdecl sub_4036BB(int a1)
{
  LPVOID v1; // esi@1
  signed int v2; // ebx@3
  int v3; // edi@3
  unsigned int v4; // eax@6
  char v5; // zf@9
  LPVOID v6; // ecx@11
  int v7; // eax@13
  signed int v8; // edx@13
  int v9; // [sp+Ch] [bp-4h]@3

  v1 = off_4075AC;
  do
  {
    if ( *((_DWORD *)v1 + 4) != -1 )
    {
      v9 = 0;
      v3 = (int)((char *)v1 + 8208);
      v2 = 4190208;
      do
      {
        if ( *(_DWORD *)v3 == 240 )
        {
          if ( VirtualFree((LPVOID)(*((_DWORD *)v1 + 4) + v2), 0x1000u, 0x4000u) )
          {
            *(_DWORD *)v3 = -1;
            --dword_409BEC;
            v4 = *((_DWORD *)v1 + 3);
            if ( !v4 || v4 > v3 )
              *((_DWORD *)v1 + 3) = v3;
            ++v9;
            v5 = a1-- == 1;
            if ( v5 )
              break;
          }
        }
        v2 -= 4096;
        v3 -= 8;
      }
      while ( v2 >= 0 );
      v6 = v1;
      v1 = (LPVOID)*((_DWORD *)v1 + 1);
      if ( v9 )
      {
        if ( *((_DWORD *)v6 + 6) == -1 )
        {
          v7 = (int)((char *)v6 + 32);
          v8 = 1;
          do
          {
            if ( *(_DWORD *)v7 != -1 )
              break;
            ++v8;
            v7 += 8;
          }
          while ( v8 < 1024 );
          if ( v8 == 1024 )
            sub_403665((void **)v6);
        }
      }
    }
  }
  while ( v1 != off_4075AC && a1 > 0 );
}
// 409BEC: using guessed type int dword_409BEC;

//----- (0040377D) --------------------------------------------------------
int __cdecl sub_40377D(unsigned int a1, int a2, int a3)
{
  void **v3; // ecx@1

  v3 = &off_4075A8;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_4075A8 )
      return 0;
  }
  if ( !(a1 & 0xF) && (a1 & 0xFFF) >= 0x100 )
  {
    *(_DWORD *)a2 = v3;
    *(_DWORD *)a3 = a1 & 0xF000;
    return ((signed int)(a1 - (unsigned __int16)(a1 & 0xF000) - 256) >> 4) + (unsigned __int16)(a1 & 0xF000) + 8;
  }
  return 0;
}
// 4075A8: using guessed type void *off_4075A8;

//----- (004037D4) --------------------------------------------------------
void __cdecl sub_4037D4(int a1, int a2, int a3)
{
  int v3; // eax@1
  char v4; // zf@1

  v3 = a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24;
  *(_DWORD *)v3 += *(_BYTE *)a3;
  *(_BYTE *)a3 = 0;
  v4 = *(_DWORD *)v3 == 240;
  *(_DWORD *)(v3 + 4) = 241;
  if ( v4 )
  {
    ++dword_409BEC;
    if ( dword_409BEC == 32 )
      sub_4036BB(16);
  }
}
// 409BEC: using guessed type int dword_409BEC;

//----- (00403819) --------------------------------------------------------
int __cdecl sub_403819(unsigned int a1)
{
  void **v1; // esi@1
  void *v2; // edx@2
  int v3; // eax@3
  int v4; // edi@3
  unsigned int v5; // ebx@4
  int result; // eax@6
  void **v7; // edi@22
  void *v8; // eax@27
  void *v9; // ebx@27
  int i; // esi@27
  unsigned int v11; // ecx@31
  int v12; // eax@32
  int v14; // eax@34
  unsigned __int8 v15; // cf@35
  LPVOID v16; // eax@40
  int v17; // ecx@41
  unsigned int v18; // [sp+Ch] [bp-8h]@11
  int v19; // [sp+10h] [bp-4h]@3
  int v20; // [sp+10h] [bp-4h]@11
  signed int v21; // [sp+10h] [bp-4h]@27

  v1 = off_4095C8;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v4 = (int)v1[2];
      v3 = (int)((char *)v2 + 4096 * ((signed int)(v1[2] - v1 - 24) >> 3));
      v19 = (int)((char *)v2 + 4096 * ((signed int)(v1[2] - v1 - 24) >> 3));
      if ( v4 < (unsigned int)(v1 + 2054) )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( *(_DWORD *)v4 >= (signed int)a1 && *(_DWORD *)(v4 + 4) > a1 )
          {
            result = sub_403A21(v3, *(_DWORD *)v4, a1);
            if ( result )
            {
LABEL_21:
              off_4095C8 = v1;
              *(_DWORD *)v4 -= v5;
              v1[2] = (void *)v4;
              return result;
            }
            v3 = v19;
            *(_DWORD *)(v4 + 4) = a1;
          }
          v4 += 8;
          v3 += 4096;
          v19 = v3;
          if ( v4 >= (unsigned int)(v1 + 2054) )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v4 = (int)(v1 + 6);
      v18 = (unsigned int)v1[2];
      v20 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < v18 )
      {
        do
        {
          if ( *(_DWORD *)v4 >= (signed int)v5 && *(_DWORD *)(v4 + 4) > v5 )
          {
            result = sub_403A21(v20, *(_DWORD *)v4, v5);
            if ( result )
              goto LABEL_21;
            *(_DWORD *)(v4 + 4) = v5;
          }
          v20 += 4096;
          v4 += 8;
        }
        while ( v4 < v18 );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_4095C8 );
  v7 = &off_4075A8;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_4075A8 )
    {
      v16 = sub_403521();
      if ( v16 )
      {
        v17 = *((_DWORD *)v16 + 4);
        *(_BYTE *)(v17 + 8) = v5;
        off_4095C8 = (void **)v16;
        *(_DWORD *)v17 = v17 + v5 + 8;
        *(_DWORD *)(v17 + 4) = 240 - v5;
        *((_DWORD *)v16 + 6) -= (unsigned __int8)v5;
        return v17 + 256;
      }
      return 0;
    }
  }
  v9 = v7[3];
  v21 = 0;
  v8 = v9;
  for ( i = (int)((char *)v7[4] + 4096 * ((signed int)(v9 - v7 - 24) >> 3)); *(_DWORD *)v8 == -1; ++v21 )
  {
    if ( v21 >= 16 )
      break;
    v8 = (char *)v8 + 8;
  }
  if ( VirtualAlloc((LPVOID)i, v21 << 12, 0x1000u, 4u) != (LPVOID)i )
    return 0;
  memset((void *)i, v21 << 12, 0);
  v11 = (unsigned int)v9;
  if ( v21 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *(_DWORD *)v11 = 240;
      *(_DWORD *)(v11 + 4) = 241;
      v12 += 4096;
      v11 += 8;
    }
    while ( v21-- != 1 );
  }
  off_4095C8 = v7;
  v14 = (int)(v7 + 2054);
  while ( 1 )
  {
    v15 = v11 < v14;
    if ( v11 >= v14 )
      break;
    if ( *(_DWORD *)v11 == -1 )
    {
      v15 = v11 < v14;
      break;
    }
    v11 += 8;
  }
  v7[3] = (void *)(v11 & -v15);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v9;
  *(_DWORD *)v9 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = i + 256;
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 4075A8: using guessed type void *off_4075A8;
// 4095C8: using guessed type void **off_4095C8;

//----- (00403A21) --------------------------------------------------------
int __cdecl sub_403A21(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  unsigned int v6; // edi@1
  unsigned int v7; // esi@1
  int v8; // eax@5
  int v9; // esi@6
  int v10; // ebx@10
  signed int v11; // esi@10
  int v12; // esi@20
  signed int v13; // eax@24
  int v14; // ebx@24
  unsigned int v16; // [sp+Ch] [bp-4h]@1
  int v17; // [sp+18h] [bp+8h]@1

  v4 = a1;
  v7 = *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)a1;
  v5 = a1 + 248;
  v16 = *(_DWORD *)a1;
  v3 = *(_DWORD *)a1;
  v17 = a1 + 248;
  if ( v7 >= a3 )
  {
    *(_BYTE *)v6 = a3;
    if ( v6 + a3 >= v5 )
    {
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)v4 = v4 + 8;
    }
    else
    {
      *(_DWORD *)v4 += a3;
      *(_DWORD *)(v4 + 4) -= a3;
    }
    v8 = v6 + 8;
    return 16 * v8 - 15 * v4;
  }
  v9 = v6 + v7;
  if ( *(_BYTE *)v9 )
    v3 = v9;
  if ( v3 + a3 >= v5 )
  {
LABEL_20:
    v12 = v4 + 8;
    while ( v12 < v6 && v12 + a3 < v17 )
    {
      if ( *(_BYTE *)v12 )
      {
        v12 += *(_BYTE *)v12;
      }
      else
      {
        v14 = v12 + 1;
        v13 = 1;
        while ( !*(_BYTE *)v14 )
        {
          ++v14;
          ++v13;
        }
        if ( v13 >= a3 )
        {
          if ( v12 + a3 >= v17 )
          {
            *(_DWORD *)(v4 + 4) = 0;
            *(_DWORD *)v4 = v4 + 8;
          }
          else
          {
            *(_DWORD *)v4 = v12 + a3;
            *(_DWORD *)(v4 + 4) = v13 - a3;
          }
          *(_BYTE *)v12 = a3;
          v8 = v12 + 8;
          return 16 * v8 - 15 * v4;
        }
        a2 -= v13;
        if ( a2 < a3 )
          return 0;
        v12 = v14;
      }
    }
    return 0;
  }
  while ( *(_BYTE *)v3 )
  {
    v3 += *(_BYTE *)v3;
LABEL_19:
    if ( v3 + a3 >= v17 )
      goto LABEL_20;
  }
  v10 = v3 + 1;
  v11 = 1;
  while ( !*(_BYTE *)v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v3 == v16 )
    {
      *(_DWORD *)(v4 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v6 = v16;
    v3 = v10;
    goto LABEL_19;
  }
  if ( v3 + a3 >= v17 )
  {
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)v4 = v4 + 8;
  }
  else
  {
    *(_DWORD *)v4 = v3 + a3;
    *(_DWORD *)(v4 + 4) = v11 - a3;
  }
  *(_BYTE *)v3 = a3;
  v8 = v3 + 8;
  return 16 * v8 - 15 * v4;
}

//----- (00403C1D) --------------------------------------------------------
int __cdecl sub_403C1D()
{
  return flsall(1);
}
// 403C26: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (00403F8A) --------------------------------------------------------
void *__cdecl sub_403F8A(size_t Size, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // cf@1
  unsigned __int8 v4; // zf@1
  void *v5; // edi@5
  size_t v7; // [sp-4h] [bp-Ch]@17
  unsigned int v8; // [sp+10h] [bp+8h]@1

  v2 = a2 * Size;
  v3 = a2 * Size < 0xFFFFFFE0;
  v4 = a2 * Size == -32;
  v8 = a2 * Size;
  if ( v3 | v4 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  do
  {
    v5 = 0;
    if ( (unsigned int)v2 > 0xFFFFFFE0 )
      goto LABEL_14;
    if ( dword_409E88 == 3 )
    {
      if ( v8 > dword_409E80 || (v5 = (void *)__sbh_alloc_block(v8), !v5) )
        goto LABEL_13;
      v7 = v8;
LABEL_18:
      memset(v5, 0, v7);
      return v5;
    }
    if ( dword_409E88 == 2 )
    {
      if ( v2 <= (unsigned int)dword_4095CC )
      {
        v5 = (void *)sub_403819((unsigned int)v2 >> 4);
        if ( v5 )
        {
          v7 = v2;
          goto LABEL_18;
        }
      }
    }
LABEL_13:
    v5 = HeapAlloc(hHeap, 8u, v2);
    if ( v5 )
      return v5;
LABEL_14:
    if ( !dword_409BF0 )
      return v5;
  }
  while ( _callnewh(v2) );
  return 0;
}
// 40306C: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 403B45: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 4095CC: using guessed type int dword_4095CC;
// 409BF0: using guessed type int dword_409BF0;
// 409E80: using guessed type int dword_409E80;
// 409E88: using guessed type int dword_409E88;

//----- (00405A89) --------------------------------------------------------
unsigned int __cdecl sub_405A89(unsigned int a1)
{
  unsigned int result; // eax@1
  int v2; // edx@1

  v2 = 0;
  dword_409A94 = a1;
  result = (unsigned int)&unk_409910;
  do
  {
    if ( a1 == *(_DWORD *)result )
    {
      result = dword_409914[2 * v2];
      dword_409A90 = dword_409914[2 * v2];
      return result;
    }
    result += 8;
    ++v2;
  }
  while ( result < (unsigned int)&Str );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || (dword_409A90 = 8, a1 > 0xCA) )
      dword_409A90 = 22;
  }
  else
  {
    dword_409A90 = 13;
  }
  return result;
}
// 409914: using guessed type int dword_409914[];
// 409A90: using guessed type int dword_409A90;
// 409A94: using guessed type int dword_409A94;

// ALL OK, 21 function(s) have been successfully decompiled
